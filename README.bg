			Отчитане на мрежови трафик
			Network Traffic Accounting daemon

Описание:

Програмата служи за отчитане на мрежови трафик минаващ през вашият 
рутер/гейтуей. Базирана е на библиотеката libpcap и работи като userspace
демон. Възможности за разделяне на мрежовия трафик на 4 категории:
 - международен
 - пиъринг
 - директен
 - локален
Отчетения трафик се съхранява в база данни като за момента се поддържат
MySQL и Oracle. Тъй като използва libpcap за събиране на мрежовата информация
програмата работи на следните (за момента) операционни системи:
 - Linux
 - FreeBSD
 - OpenBSD
 - Solaris
За специфична информация касаеща определена операционна система прочетете
FAQ файла.

Как работи:

Netacct работи по подобие на sniffer тоест следи целият трафик минаващ
пред зададените от конфигурационния файл интерфейси. Данните се събират в
паметта и периодично се записват в базата данни. Периода на записване на
данните по подразбиране е 300 секунди (виж опция flush в конфигурационния
файл). 

Конфигурация:

За отчитане на мрежови трафик най-удачната конфигурация е отчитащата
програма да работи на Вашия маршрутизатор. Програмата има 2 конфигурационни
файла като по долу ще бъдат разяснени по важните опции:

naccttab
--------

 sniff - може да заема стойности 0 или 1
  0 - мрежовите интерфейси не се поставят в режим на подслушване
	1 - мрежовите интерфейси се поставят в режим на подслушване

 database - стойности mysql или oracle
  mysql - работа с MySQL база данни (слеват специфични опции за mysql):
	 mysql_user - потребителско име за връзка с базата данни
	 mysql_pass - парола за базата данни
	 mysql_host - обикновенно localhost но може да работи и с отдалечена база
	 	база данни
	 mysql_port - ако MySQL-а е на същатата машина препорачително е порта да 
	 	е равен на 0 което означава че връзката ще се прави през сокет.
	 mysql_database - името на базата в която ще се съхраняват данните
	 
	oracle - работа с ORACLE база данни
	 oracle_connect - 
	 oracle_home - /пътя/до/оракъл/директорията
 
 compactnet - С тази опция се описват мрежите на които искате да се засича
 	трафика. Форматът на задаване е: compactnet мрежови_адрес мрежова_маска
	(example: compactnet 192.168.1.0 255.255.255.0). Опцията може да бъде
	описана в конфигурационния файл повече от един път.
	
 ournet - тази опция е за засичането на локален трафик или по друг начин
 	казано трафик между 2 интерфйса на рутера. В повечето случаи ournet
	съвпада с compactnet опциите. Повече информация в примерните конфигурации
	описани по долу.
	
 direct_peer - (мрежови_адрес мрежова_маска) тази опция може да
 	я ползвате при наличие на допалнителна локална връзка към друг доставчик
	примерно backup линия или имате локално ftp които трафик искате да
	отчитате отделно. В общи линии това се използва в редки случай.
	Забележка: опцията трябва да присъства поне веднъж в конфигурационния
	файл. Ако не искате да засичате такъв тип трафик напишете примерно:
	direct_peer 1.1.1.1 255.255.255.255
	
 flush - Интервал през който се записват данните в базата (в секунди)
 
 device - мрежови интерфейс от който ще се събира трафик информацията.
 	Може да присъства повече от 1 път в конфигурационния файл. 
	Примери (Linux): 
	 device eth1 
	 device eth2
	Примери (*BSD):
	 device rtk0
	 device sk0
	 
 ignorenet - (мрежови_адрес мрежова_маска) ако искате да игнорирате трафика
 	от някоя определена мрежа използвайте тази опция. Опцията може да присъства
	повече от един път в конфигурационния файл.

 (Само за напреднали потребители)
 
 pidfile - /път/до/netacct.pid файла. Дава ви възможност да пуснете два или
	повече процеса на програмата на една и съща машина.
 
 errdelay - (в пъти) тази опция ви позволява да конфигурирате времезакъснението
 	на опита за писане в базата данни при появата на грешка. Ако възникне
	грешка при опит за писане в базата данни тогава netacct ще изчака
	flush * errdelay време преди следващия опит за писане. Тоест ако flush = 300
	и errdelay = 3 то при грешка следващия опит ще е след 900 секунди.

nacctpeering
 
 Мрежите за така наречения пиъринг са отделени в отделен файл за удобство
 тъй като мрежите могът да бъдат обновявани периодично от някой интернет
 сайт или да се извличат от BGP. Killall -HUP nacctd ще презареди този
 файл в паметта. Форматът е:

 мрежа/мрежова_маска
  или
 мрежа/инвертирана_маска

 Пример:
 195.187.245.0/255.255.255.0
  или
 195.187.245/24

Примери:

Ето няколко примера на конфигурационния файл за най-често 
срещаните мрежови конфигурации:

ПРИМЕР 1

eth0 - 62.73.87.1 netmask 255.255.255.252
eth1 - 192.168.1.0 255.255.255.0
eth2 - 10.0.0.0 255.255.255.0
eth2:0 - 10.10.10.0 255.255.255.0

тоест eth0 е default gateway-а на eth1 имаме една мрежа от IP-та а на
eth2 имаме 2 мрежи. Искаме да засичаме трафика само намрежата
10.10.10.0 с маска 255.255.255.0
Забележка: тук ще дам пример само с основните конфигурационни неща като
всичко останало си остава същото
Забележка 2: IP адресите които използвам за примери са от частни мрежи
но Вие трябва да ги разбирате просто като мрежи и спокойно може да ги
замените с която и да е реална мрежа. Важното е да разберете разположението
на мрежите по интерфейсите и начина на описване в конфигурационния файл.

naccttab:
---[cut]---
compactnet 10.10.10.0 255.255.255.0
ournet 10.10.10.0 255.255.255.0
ournet 10.0.0.0 255.255.255.0
ournet 192.168.1.0 255.255.255.0
direct_peer 1.1.1.1 255.255.255.255
device eth2
ignorenet 127.0.0.0 255.0.0.0
---[cut]---

Пояснения:
имаме 3 пъти ournet опцията както виждате за да може трафика между:
10.10.10.0 <-> 10.0.0.0
10.10.10.0 <-> 192.168.1.0
да бъде отчетен като локален
за device eth2 тай като това все пак си е физически интерфейс libpcap
отчита целиа трафик минал през него така че alias интерфейсите не ни 
интересуват.
Както споменах и по-горе не искаме да отчитаме direct_peer трафик но за да
не остане неинициализирана промелнивата описваме IP-to 1.1.1.1
и накрая игнорираме всичкия трафик към lo интерфейса.

ПРИМЕР 2
конфигурацията е като на ПРИМЕР 1 но искаме да отчитаме всичкия трафик до
частните мрежи. Ето как ще се промени конфигурацията:
naccttab:
---[cut]---
compactnet 10.10.10.0 255.255.255.0
compactnet 10.0.0.0 255.255.255.0
compactnet 192.168.1.0 255.255.255.0
ournet 10.10.10.0 255.255.255.0
ournet 10.0.0.0 255.255.255.0
ournet 192.168.1.0 255.255.255.0
direct_peer 1.1.1.1 255.255.255.255
device eth1
device eth2
ignorenet 127.0.0.0 255.0.0.0
---[cut]---

Пояснения:
Както забелязвате добавени са още 2 реда compactnet и един ред с device
тъй като 192.168.1.0 се намира на друг мрежови интерфейс.

ПРИМЕР 3

eth0 - 62.73.87.1 netmask 255.255.255.252
eth1 - 192.168.1.0 255.255.255.0
eth1:0 - 192.168.20.0 255.255.255.248
eth2 - 10.0.0.0 255.255.255.0
eth2:0 - 10.10.10.0 255.255.255.0

тоест eth0 е default gateway-а на eth1 имаме 2 една мрежи от IP-та и на
eth2 имаме 2 мрежи. Искаме да засичаме всичкия трафик освен на мрежата
192.168.20.0 на която сме сложили няколко локални сървъра:
192.168.20.2 - ftp сървър
192.168.20.3 - game server 1
192.168.20.3 - game server 2
192.168.20.4 - game server 3
това са примерни неща идеята е че трафика към тези сървъри е само за локални
клиенти и не се заплаща или да речем се заплаща по много ниска тарифа
но все пак искаме да засичаме кои колко трафик прави от безплатния. Удобно
е за отсяване на клиентите които правят много локален и (почти) никакъв
реален трафик. Ето и конфигурацията:

naccttab:
---[cut]---
compactnet 10.10.10.0 255.255.255.0
compactnet 10.0.0.0 255.255.255.0
compactnet 192.168.1.0 255.255.255.0
ournet 10.10.10.0 255.255.255.0
ournet 10.0.0.0 255.255.255.0
ournet 192.168.1.0 255.255.255.0
direct_peer 192.168.20.0 255.255.255.0
device eth1
device eth2
ignorenet 127.0.0.0 255.0.0.0
---[cut]---

Както забелязвате единствената разлика е че мрежата с game сървърите е
сложена в direct_peer и трафика към нея ще се засича в графа директен
трафик. Мрежата НЕ присъства в compactnet защото ще засъчаме трафик
_ОТ_ ip адресите в compactnet _КЪМ_ ip адресите в direct_peer.

ПРИМЕР 4

Конфигурация при ползването на прокси сървър
ВАЖНО: програмата ще отчита правилно САМО ако проксито е настроено да
работи като TRANSPARENT proxy. В противен случай тъй като целия трафик
минава през него (на потребителя се правят настройки на браузъра) винаги
или source ip или destination ip е прокси сървъра няма как да се разграничи
вида трафик. Трафика пак че е отчетен правилно но всичкия ще попадне или
в международен или в пиъринг или в директ. Затова удачното решение е 
на потребителя да не се правят никакви настройки а трафика да се пренасочва
с iptables (ipf,pf) към ip адреса и порта на проксито.

eth0 - 62.73.87.1 netmask 255.255.255.252
eth1 - 192.168.1.0 255.255.255.0

прокси сървъра работи на същата машина на порт 3128

# iptables конфигурация
iptables -t nat -A PREROUTING -s 192.168.1.0/24 -d 0/0 -p tcp -m multiport --dport 80,21,8080 -j REDIRECT --to-port 3128
# pf конфигурациа
rdr on fxp0 inet proto tcp to port 80 -> 10.10.10.10 port 8080

naccttab:
---[cut]---
compactnet 192.168.1.0 255.255.255.0
ournet 192.168.1.0 255.255.255.0
direct_peer 1.1.1.1 255.255.255.255
device eth1
ignorenet 127.0.0.0 255.0.0.0
---[cut]---

Както забелязвате конфигурацията е проста.

Техническа информация:

В базата се записват сумирани стоиности за последния час за всяко IP тоест
ако интервана за записване е 300 секунди netacct ще провери дали има запис
за текущият час и дата за това IP в базата. Ако няма ще направи INSERT в
базата ново поле с текущата сабрана информация за трафика а ако има вече
такъв запис ще добави към тях сабраната до момента информация и ще я
запише в базата.

Ето как изглеждат записите за един IP адрес в базата.

 hour     international         peering          direct         local
          in        out       in      out       in      out    in  out  
+-----+-------------------+-----------------+----------------+----------+
|08:00| 5,164,960 498,371 | 824,024 240,049 | 125,155 76,058 |260,853 0 |
+-----+-------------------+-----------------+----------------+----------+
|09:00| 8,794,618 710,045 |1,354,427 413,418|   1,488 1,033  |326,594 0 |
+-----+-------------------+-----------------+----------------+----------+
|10:00| 1,324,960 434,371 | 824,024 240,049 | 125,155 76,058 |260,853 0 |
+-----+-------------------+-----------------+----------------+----------+
|11:00| 2,164,960 128,344 | 434,323 233,144 | 231,225 67,831 |120,742 0 |
+-----+-------------------+-----------------+----------------+----------+
|12:00|   111,141 122,222 | 846,111 988,865 | 235,001 43,433 |311,143 0 |       +-----+-------------------+-----------------+----------------+----------+

Единственото ограничение за количеството трафик е следната:
количеството трафик отчетен за периода на записване (да кажем 300 секунди)
не трябва да надхвърля 4 Гигабайта. Ако имате такова УЖАСНО натоварване
на мрежата (предполагам че е възможно на 10Gbit мрежи) препорачително е да
намалите flush стоиността на по-малка.

Използване (за напреднали):

Можете да контролирате netacct като му подавате сигнали с командата
kill. Основно ще ви се наложи да ползвате 3 сигнала и те са:

HUP		- презарежда nacctpeering файла. Удобен при често промяна на peering мрежите
TSTP	- забранява записването на трафика в базата данни
CONT	- разрешава записването на трафика в базата данни

TSTP и CONT са удобни при ъпгрейд или автоматично архивиране на SQL базите
Пример:

#!/bin/sh
 killall -TSTP nacctd
 тук_спирате_sql_сървъра
 тук_архивирате_каквото_има_за_архивиране_или_ъпгрейд
 killall -CONT nacctd

Обновяване на пиъринг файла (за България):

 #!/bin/bash
 lynx -dump http://www.nat.bg/look/AS/networks.html > /tmp/bgn
 cat /tmp/bgn |grep -v "/AS"|grep -v "255.255"|grep "]AS"|awk '{print $2}' > /usr/local/etc/nacctpeering
 rm -f /tmp/bgn
 killall -HUP nacctd

 В contrib/ директорията можете да намерите списъци с мрежи за определени
 страни които най-вероятно не са актуални вече. Ако мрежите на вашата страна
 ги няма там можете да ми ги изпратите за да бъдат добавени.
  

Още по техническа информация:

Ето как програмата проверява всеки един пакет в кой тип трафик да попадне:

0. проверява дали src_ip или dst_ip на пакета съвпада с някоя от мрежите в
	compactnet ако не този пакет се игнорира
1. проверява дали src_ip или dst_ip на пакета съвпада с някоя от мрежите в 
  our .. ако да тогава пакета се записва като локален и продалжава проверката
	със следващия пакет.
2. проверява дали src_ip или dst_ip на пакета съвпада с някоя от мрежите в 
	direct_peer .. ако да тогава пакета се записва като директен и продалжава 
	проверката със следващия пакет.
3. проверява дали src_ip или dst_ip на пакета съвпада с някоя от мрежите в
	nacctpeering файла .. ако да тогава пакета се записва като пиъринг и 
	продалжава  проверката със следващия пакет.
4. ако пакета не е попаднал в нито една от категории от 1 до 3 се записва
	като международен

Не спираите програмата с kill -9 сигнала защото ще загубите данните отчетени
от последното записване в базата до момента на kill. Най-добре е да се
спира с -TERM сигнала. В този случай автоматично ще бъдат записани последните
отчетени данни в базата преди програмата да бъде спряна.

Nikolay Hristov <geroy@stemo.bg>, <geroy@users.sourceforge.net>
